<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EXTREME PONG</title>
  
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Russo+One&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --primary: #00fcff;
      --primary-dark: #0083b0;
      --secondary: #ff00ff;
      --tertiary: #ffff00;
      --background: #0f0f2a;
      --text: #ffffff;
      --panel: rgba(0, 20, 40, 0.85);
      --accent: #ff00ff;
      --success: #00ff66;
      --warning: #ffcc00;
      --danger: #ff3366;
    }
    
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      background: #000033;
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      color: var(--text);
    }
    
    canvas {
      border: 2px solid var(--primary);
      box-shadow: 0 0 20px rgba(0, 252, 255, 0.5);
      margin-top: 20px;
      margin-bottom: 20px;
      background: #000033;
    }
    
    h1 {
      font-size: 2.5em;
      margin: 20px 0;
      text-align: center;
      color: var(--primary);
      text-shadow: 0 0 10px var(--primary);
    }
    
    .score-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    #scores {
      font-size: 36px;
      font-weight: 900;
      text-align: center;
      padding: 10px 30px;
      background: rgba(0, 10, 30, 0.7);
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(0, 252, 255, 0.5);
      text-shadow: 0 0 15px var(--primary);
      font-family: 'Russo One', sans-serif;
      border: 2px solid var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 250px;
    }
    
    .player-score {
      margin: 0 15px;
      padding: 5px 15px;
      min-width: 60px;
      text-align: center;
    }
    
    .player-score.left {
      color: var(--primary);
    }
    
    .player-score.right {
      color: var(--secondary);
    }
    
    .controls-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .button-container {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    button {
      background: transparent;
      color: var(--text);
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 16px;
      padding: 12px 24px;
      min-width: 150px;
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 10px var(--primary);
    }
    
    button:hover {
      background-color: var(--primary);
      color: #000033;
    }
    
    button.active {
      background-color: var(--primary);
      color: #000033;
    }
    
    .controls-help {
      margin-top: 20px;
      text-align: center;
    }
    
    .key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 252, 255, 0.1);
      border: 1px solid var(--primary);
      padding: 5px 12px;
      border-radius: 6px;
      margin: 0 5px;
      min-width: 30px;
      height: 30px;
      box-shadow: 0 0 5px rgba(0, 252, 255, 0.3);
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
    }
    
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 20, 40, 0.9);
      border-left: 4px solid var(--primary);
      padding: 15px 20px;
      border-radius: 6px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      animation: slideIn 0.3s forwards, fadeOut 0.5s forwards 2.5s;
      max-width: 300px;
    }
    
    @keyframes slideIn {
      from { transform: translateX(110%); }
      to { transform: translateX(0); }
    }
    
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; visibility: hidden; }
    }
  </style>
</head>
<body>
  <h1>EXTREME PONG</h1>
  
  <div class="score-container">
    <div id="scores">
      <div class="player-score left">0</div>
      <div class="player-score right">0</div>
    </div>
  </div>
  
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <div class="controls-container">
    <div class="button-container">
      <button id="startButton">START GAME</button>
      <button id="resetButton">RESET</button>
      <button id="pauseButton">PAUSE</button>
    </div>
    
    <div class="button-container" id="gameModeButtons">
      <button id="ai-vs-ai" class="active">AI vs AI</button>
      <button id="human-vs-ai">Human vs AI</button>
      <button id="ai-vs-human">AI vs Human</button>
      <button id="human-vs-human">2 Players</button>
    </div>
    
    <div class="controls-help">
      <div>Left Paddle: <span class="key">W</span> (up) / <span class="key">S</span> (down)</div>
      <div>Right Paddle: <span class="key">↑</span> (up) / <span class="key">↓</span> (down)</div>
      <div>Pause: <span class="key">P</span> or <span class="key">ESC</span></div>
    </div>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game constants
    const paddleWidth = 15;
    const paddleHeight = 100;
    const ballRadius = 10;
    const powerUpSize = 20;
    
    // Game variables
    let leftPaddle = {
      x: 30,
      y: canvas.height / 2 - paddleHeight / 2,
      vy: 0,
      height: paddleHeight,
      width: paddleWidth,
      speed: 5,
      score: 0,
      isAI: true,
      difficulty: 'normal',
      activePowerUps: []
    };
    
    let rightPaddle = {
      x: canvas.width - 30 - paddleWidth,
      y: canvas.height / 2 - paddleHeight / 2,
      vy: 0,
      height: paddleHeight,
      width: paddleWidth,
      speed: 5,
      score: 0,
      isAI: true,
      difficulty: 'normal',
      activePowerUps: []
    };
    
    let ball = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      dx: 4,
      dy: 2,
      radius: ballRadius,
      speed: 4
    };
    
    // Game state variables
    let gameState = 'start'; // start, playing, paused, gameOver, finished
    let powerUps = [];
    let powerUpTimer = 0;
    let gameSpeed = 1;
    let maxPoints = 10;
    let randomness = 15;
    let consecutiveHits = 0;
    
    // Power-up types and their chances
    const POWER_UP_TYPES = ['speed', 'giant', 'shrink', 'shield', 'ballSpeed', 'ghost', 'multiBall', 'freeze'];
    const POWER_UP_CHANCES = {
      speed: 10,
      giant: 10,
      shrink: 10,
      shield: 10,
      ballSpeed: 10,
      ghost: 10,
      multiBall: 10,
      freeze: 10
    };
    
    // Keyboard controls
    const keys = {
      w: false,
      s: false,
      ArrowUp: false,
      ArrowDown: false
    };
    
    // Event listeners for keyboard
    window.addEventListener('keydown', e => {
      if (e.key in keys) {
        keys[e.key] = true;
        e.preventDefault();
      }
      
      if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
        if (gameState === 'playing') {
          gameState = 'paused';
        } else if (gameState === 'paused') {
          gameState = 'playing';
        }
      }
    });
    
    window.addEventListener('keyup', e => {
      if (e.key in keys) {
        keys[e.key] = false;
        e.preventDefault();
      }
    });
    
    // Button event listeners
    document.getElementById('startButton').addEventListener('click', () => {
      if (gameState === 'start' || gameState === 'paused' || gameState === 'gameOver') {
        gameState = 'playing';
      }
    });
    
    document.getElementById('resetButton').addEventListener('click', resetGame);
    
    document.getElementById('pauseButton').addEventListener('click', () => {
      if (gameState === 'playing') {
        gameState = 'paused';
      } else if (gameState === 'paused') {
        gameState = 'playing';
      }
    });
    
    // Game mode buttons
    document.getElementById('ai-vs-ai').addEventListener('click', () => setGameMode('ai-vs-ai'));
    document.getElementById('human-vs-ai').addEventListener('click', () => setGameMode('human-vs-ai'));
    document.getElementById('ai-vs-human').addEventListener('click', () => setGameMode('ai-vs-human'));
    document.getElementById('human-vs-human').addEventListener('click', () => setGameMode('human-vs-human'));
    
    // Set game mode
    function setGameMode(mode) {
      // Update button highlighting
      document.querySelectorAll('#gameModeButtons button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(mode).classList.add('active');
      
      // Update paddles
      switch(mode) {
        case 'ai-vs-ai':
          leftPaddle.isAI = true;
          rightPaddle.isAI = true;
          break;
        case 'human-vs-ai':
          leftPaddle.isAI = false;
          rightPaddle.isAI = true;
          break;
        case 'ai-vs-human':
          leftPaddle.isAI = true;
          rightPaddle.isAI = false;
          break;
        case 'human-vs-human':
          leftPaddle.isAI = false;
          rightPaddle.isAI = false;
          break;
      }
      
      resetGame();
    }
    
    // Reset game
    function resetGame() {
      // Reset paddles
      leftPaddle.y = canvas.height / 2 - paddleHeight / 2;
      leftPaddle.score = 0;
      leftPaddle.activePowerUps = [];
      leftPaddle.height = paddleHeight;
      
      rightPaddle.y = canvas.height / 2 - paddleHeight / 2;
      rightPaddle.score = 0;
      rightPaddle.activePowerUps = [];
      rightPaddle.height = paddleHeight;
      
      // Reset ball
      resetBall();
      
      // Reset game state
      powerUps = [];
      powerUpTimer = 0;
      consecutiveHits = 0;
      gameState = 'start';
      
      // Update score display
      updateScoreDisplay();
    }
    
    // Reset ball position and velocity
    function resetBall() {
      ball.x = canvas.width / 2;
      ball.y = canvas.height / 2;
      
      // Random direction
      let angle = Math.random() * Math.PI / 4 - Math.PI / 8;
      if (Math.random() < 0.5) angle += Math.PI;
      
      ball.dx = Math.cos(angle) * ball.speed;
      ball.dy = Math.sin(angle) * ball.speed;
    }
    
    // Update score display
    function updateScoreDisplay() {
      document.querySelector('.player-score.left').textContent = leftPaddle.score;
      document.querySelector('.player-score.right').textContent = rightPaddle.score;
    }
    
    // Update game state
    function update() {
      // Skip updates if game is not active
      if (gameState !== 'playing') return;
      
      // Process player input for human-controlled paddles
      if (!leftPaddle.isAI) {
        leftPaddle.vy = 0;
        if (keys.w) leftPaddle.vy = -leftPaddle.speed;
        if (keys.s) leftPaddle.vy = leftPaddle.speed;
      }
      
      if (!rightPaddle.isAI) {
        rightPaddle.vy = 0;
        if (keys.ArrowUp) rightPaddle.vy = -rightPaddle.speed;
        if (keys.ArrowDown) rightPaddle.vy = rightPaddle.speed;
      }
      
      // Update paddle positions
      leftPaddle.y += leftPaddle.vy;
      rightPaddle.y += rightPaddle.vy;
      
      // Keep paddles within bounds
      leftPaddle.y = Math.max(0, Math.min(canvas.height - leftPaddle.height, leftPaddle.y));
      rightPaddle.y = Math.max(0, Math.min(canvas.height - rightPaddle.height, rightPaddle.y));
      
      // AI paddle movement
      if (leftPaddle.isAI) moveAI(leftPaddle);
      if (rightPaddle.isAI) moveAI(rightPaddle);
      
      // Move ball
      ball.x += ball.dx;
      ball.y += ball.dy;
      
      // Ball collision with top and bottom walls
      if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
        ball.dy = -ball.dy;
        
        // Add slight randomness to bounces
        ball.dy += (Math.random() - 0.5) * (randomness / 100);
      }
      
      // Ball collision with paddles
      if (
        ball.x - ball.radius < leftPaddle.x + leftPaddle.width &&
        ball.x > leftPaddle.x &&
        ball.y > leftPaddle.y &&
        ball.y < leftPaddle.y + leftPaddle.height
      ) {
        // Left paddle hit
        consecutiveHits++;
        
        // Calculate bounce angle based on where the ball hit the paddle
        const relativeIntersectY = (leftPaddle.y + (leftPaddle.height / 2)) - ball.y;
        const normalizedRelativeIntersectionY = relativeIntersectY / (leftPaddle.height / 2);
        const bounceAngle = normalizedRelativeIntersectionY * (Math.PI / 4);
        
        // Calculate new velocity
        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy) * 1.05; // Small speed increase
        ball.dx = Math.cos(bounceAngle) * speed;
        ball.dy = -Math.sin(bounceAngle) * speed;
        
        // Ensure ball moves right
        if (ball.dx < 0) ball.dx = -ball.dx;
      }
      
      if (
        ball.x + ball.radius > rightPaddle.x &&
        ball.x < rightPaddle.x + rightPaddle.width &&
        ball.y > rightPaddle.y &&
        ball.y < rightPaddle.y + rightPaddle.height
      ) {
        // Right paddle hit
        consecutiveHits++;
        
        // Calculate bounce angle based on where the ball hit the paddle
        const relativeIntersectY = (rightPaddle.y + (rightPaddle.height / 2)) - ball.y;
        const normalizedRelativeIntersectionY = relativeIntersectY / (rightPaddle.height / 2);
        const bounceAngle = normalizedRelativeIntersectionY * (Math.PI / 4);
        
        // Calculate new velocity
        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy) * 1.05; // Small speed increase
        ball.dx = -Math.cos(bounceAngle) * speed;
        ball.dy = -Math.sin(bounceAngle) * speed;
        
        // Ensure ball moves left
        if (ball.dx > 0) ball.dx = -ball.dx;
      }
      
      // Ball out of bounds - scoring
      if (ball.x - ball.radius < 0) {
        // Right player scores
        rightPaddle.score++;
        if (rightPaddle.score >= maxPoints) {
          gameState = 'finished';
        } else {
          resetBall();
        }
        updateScoreDisplay();
        consecutiveHits = 0;
      } else if (ball.x + ball.radius > canvas.width) {
        // Left player scores
        leftPaddle.score++;
        if (leftPaddle.score >= maxPoints) {
          gameState = 'finished';
        } else {
          resetBall();
        }
        updateScoreDisplay();
        consecutiveHits = 0;
      }
      
      // Power up spawning
      powerUpTimer += 16.67; // Approx 60fps
      if (powerUpTimer > 5000) { // Every 5 seconds
        spawnPowerUp();
        powerUpTimer = 0;
      }
      
      // Update power-ups
      updatePowerUps();
    }
    
    // AI paddle movement
    function moveAI(paddle) {
      // Difficulty factors - higher value = more accurate
      let difficultyFactor;
      switch(paddle.difficulty) {
        case 'easy': difficultyFactor = 0.3; break;
        case 'normal': difficultyFactor = 0.6; break;
        case 'hard': difficultyFactor = 0.8; break;
        default: difficultyFactor = 0.6;
      }
      
      // Target y is where AI wants to move
      let targetY;
      
      // If ball is moving towards the AI paddle
      const isLeft = paddle === leftPaddle;
      const ballMovingTowardsPaddle = (isLeft && ball.dx < 0) || (!isLeft && ball.dx > 0);
      
      if (ballMovingTowardsPaddle) {
        // Predict where ball will cross paddle's x-position
        const slope = ball.dy / ball.dx;
        const paddleX = isLeft ? paddle.x + paddle.width : paddle.x;
        const distanceX = paddleX - ball.x;
        const predictedY = ball.y + slope * distanceX;
        
        // Add randomness based on difficulty
        targetY = predictedY + (Math.random() - 0.5) * (1 - difficultyFactor) * canvas.height;
        targetY = Math.max(paddle.height/2, Math.min(canvas.height - paddle.height/2, targetY));
      } else {
        // Return to center if ball moving away
        targetY = canvas.height / 2;
      }
      
      // Move paddle towards target
      const centerY = paddle.y + paddle.height / 2;
      if (centerY < targetY - paddle.height/8) {
        paddle.vy = paddle.speed * difficultyFactor;
      } else if (centerY > targetY + paddle.height/8) {
        paddle.vy = -paddle.speed * difficultyFactor;
      } else {
        paddle.vy = 0;
      }
    }
    
    // Power-up spawning
    function spawnPowerUp() {
      // Choose power-up type based on chances
      let r = Math.random() * 100;
      let cumulative = 0;
      let type;
      
      for (const [key, chance] of Object.entries(POWER_UP_CHANCES)) {
        cumulative += chance;
        if (r <= cumulative) {
          type = key;
          break;
        }
      }
      
      if (!type) return;
      
      // Create power-up in random position (not too close to edges)
      const x = Math.random() * (canvas.width - 200) + 100;
      const y = Math.random() * (canvas.height - 100) + 50;
      
      powerUps.push({
        type,
        x,
        y,
        size: powerUpSize,
        duration: 5000 + Math.random() * 5000, // 5-10 seconds
        collected: false
      });
    }
    
    // Update power-ups
    function updatePowerUps() {
      // Check for ball collision with power-ups
      for (let i = powerUps.length - 1; i >= 0; i--) {
        const pu = powerUps[i];
        
        if (!pu.collected) {
          // Check for collision
          const dx = ball.x - pu.x;
          const dy = ball.y - pu.y;
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          if (distance < ball.radius + pu.size/2) {
            // Determine which paddle gets the power-up
            const paddle = ball.dx > 0 ? leftPaddle : rightPaddle;
            
            // Apply power-up effect
            applyPowerUp(paddle, pu.type, pu.duration);
            
            // Mark as collected
            pu.collected = true;
            
            // Remove after a delay
            setTimeout(() => {
              powerUps = powerUps.filter(p => p !== pu);
            }, 300);
          }
        }
      }
      
      // Process active power-ups on paddles
      [leftPaddle, rightPaddle].forEach(paddle => {
        // Filter out expired power-ups
        paddle.activePowerUps = paddle.activePowerUps.filter(pu => {
          return Date.now() < pu.startTime + pu.duration;
        });
        
        // Apply active effects
        processPowerUpEffects(paddle);
      });
    }
    
    // Apply power-up to a paddle
    function applyPowerUp(paddle, type, duration) {
      // Add power-up to paddle's active power-ups
      paddle.activePowerUps.push({
        type,
        startTime: Date.now(),
        duration
      });
      
      // Show notification
      showNotification(`${paddle === leftPaddle ? 'Left' : 'Right'} paddle got ${type} power-up!`);
    }
    
    // Process power-up effects on a paddle
    function processPowerUpEffects(paddle) {
      // Reset to default values first
      paddle.height = paddleHeight;
      paddle.speed = 5;
      
      // Apply each active power-up effect
      paddle.activePowerUps.forEach(pu => {
        switch(pu.type) {
          case 'speed':
            paddle.speed = 8; // Increased speed
            break;
          case 'giant':
            paddle.height = paddleHeight * 1.5; // Bigger paddle
            break;
          case 'shrink':
            // Apply to opponent paddle
            const opponent = paddle === leftPaddle ? rightPaddle : leftPaddle;
            const hasOpponentShrink = opponent.activePowerUps.some(p => p.type === 'shrink');
            if (!hasOpponentShrink) {
              opponent.height = paddleHeight * 0.5; // Smaller opponent paddle
            }
            break;
          case 'ballSpeed':
            // Increase ball speed when moving toward opponent
            const isLeft = paddle === leftPaddle;
            const ballMovingTowardsOpponent = (isLeft && ball.dx > 0) || (!isLeft && ball.dx < 0);
            if (ballMovingTowardsOpponent) {
              // Scale up ball speed
              const speedFactor = 1.5;
              const magnitude = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
              const newMagnitude = magnitude * speedFactor;
              ball.dx = (ball.dx / magnitude) * newMagnitude;
              ball.dy = (ball.dy / magnitude) * newMagnitude;
            }
            break;
          // Other power-up effects would be implemented here
        }
      });
    }
    
    // Show notification
    function showNotification(message) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Remove after animation completes
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 3000);
    }
    
    // Draw game
    function render() {
      // Clear canvas
      ctx.fillStyle = '#000033';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw center line
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw center circle
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, 50, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.stroke();
      
      // Draw paddles
      // Left paddle
      ctx.fillStyle = '#00b4db'; // Cyan for left paddle
      drawPaddle(leftPaddle);
      
      // Right paddle
      ctx.fillStyle = '#ff00ff'; // Magenta for right paddle
      drawPaddle(rightPaddle);
      
      // Draw ball
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw power-ups
      powerUps.forEach(pu => {
        if (!pu.collected) {
          let color;
          switch(pu.type) {
            case 'speed': color = '#ffeb3b'; break;
            case 'giant': color = '#FF9800'; break;
            case 'shrink': color = '#800080'; break;
            case 'shield': color = '#2196F3'; break;
            case 'ballSpeed': color = '#f44336'; break;
            case 'ghost': color = '#FFFFFF'; break;
            case 'multiBall': color = '#00FFFF'; break;
            case 'freeze': color = '#008080'; break;
            default: color = '#00ff00';
          }
          
          // Draw power-up circle
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(pu.x, pu.y, pu.size/2, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw pulsating outer ring
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          const pulseSize = 1 + Math.sin(Date.now() * 0.005) * 0.2;
          ctx.beginPath();
          ctx.arc(pu.x, pu.y, (pu.size/2) * pulseSize, 0, Math.PI * 2);
          ctx.stroke();
        }
      });
      
      // Draw active power-ups icons on paddles
      [leftPaddle, rightPaddle].forEach(paddle => {
        let y = paddle.y;
        
        paddle.activePowerUps.forEach(pu => {
          let color;
          switch(pu.type) {
            case 'speed': color = '#ffeb3b'; break;
            case 'giant': color = '#FF9800'; break;
            case 'shrink': color = '#800080'; break;
            case 'shield': color = '#2196F3'; break;
            case 'ballSpeed': color = '#f44336'; break;
            case 'ghost': color = '#FFFFFF'; break;
            case 'multiBall': color = '#00FFFF'; break;
            case 'freeze': color = '#008080'; break;
            default: color = '#00ff00';
          }
          
          // Draw power-up indicator
          ctx.fillStyle = color;
          ctx.beginPath();
          
          const xPos = paddle === leftPaddle ? 
                      paddle.x + paddle.width + 15 : 
                      paddle.x - 15;
          
          ctx.arc(xPos, y + 10, 5, 0, Math.PI * 2);
          ctx.fill();
          
          y += 15; // Offset for next power-up
        });
      });
      
      // Draw game state overlays
      if (gameState === 'start') {
        drawCenteredText("Press START to play", canvas.width/2, canvas.height/2, 30);
      } else if (gameState === 'paused') {
        drawCenteredText("PAUSED", canvas.width/2, canvas.height/2, 40);
      } else if (gameState === 'finished') {
        const winner = leftPaddle.score > rightPaddle.score ? "LEFT" : "RIGHT";
        drawCenteredText(winner + " PLAYER WINS!", canvas.width/2, canvas.height/2 - 30, 40);
        drawCenteredText("Press RESET to play again", canvas.width/2, canvas.height/2 + 30, 25);
      }
      
      // Draw consecutive hit counter if there are enough hits
      if (consecutiveHits >= 3) {
        drawCenteredText("Rally: " + consecutiveHits, canvas.width/2, 30, 20);
      }
    }
    
    // Helper function to draw a paddle
    function drawPaddle(paddle) {
      ctx.beginPath();
      ctx.roundRect(
        paddle.x, 
        paddle.y, 
        paddle.width, 
        paddle.height, 
        5 // Rounded corners
      );
      ctx.fill();
      
      // Add glow effect
      ctx.shadowColor = ctx.fillStyle;
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    // Helper function to draw centered text
    function drawCenteredText(text, x, y, fontSize = 20) {
      ctx.font = `${fontSize}px Orbitron`;
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, x, y);
    }
    
    // Game loop
    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }
    
    // Start the game loop
    gameLoop();
    
    // Add roundRect if not supported (for older browsers)
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
        if (width < 2 * radius) radius = width / 2;
        if (height < 2 * radius) radius = height / 2;
        this.beginPath();
        this.moveTo(x + radius, y);
        this.arcTo(x + width, y, x + width, y + height, radius);
        this.arcTo(x + width, y + height, x, y + height, radius);
        this.arcTo(x, y + height, x, y, radius);
        this.arcTo(x, y, x + width, y, radius);
        this.closePath();
        return this;
      };
    }
  </script>
</body>
</html>